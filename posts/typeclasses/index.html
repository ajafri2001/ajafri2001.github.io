<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://ajafri2001.github.io/ name=base><title>
            
                Typeclasses in Scala3
            
        </title><meta content="Typeclasses in Scala3" property=og:title><link href=https://ajafri2001.github.io/fonts.css rel=stylesheet><script src=https://ajafri2001.github.io/js/codeblock.js></script><script src=https://ajafri2001.github.io/js/toc.js></script><script>MathJax = {
              tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
              }
            };</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://ajafri2001.github.io/atom.xml rel=alternate title=ajafri2001 type=application/atom+xml><link href=https://ajafri2001.github.io/theme/light.css rel=stylesheet><link href=https://ajafri2001.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://ajafri2001.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://ajafri2001.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://ajafri2001.github.io/>ajafri2001</a><div class=socials><a class=social href=https://github.com/ajafri2001/ rel=me> <img alt=github src=https://ajafri2001.github.io/icons/social/github.svg> </a><a class=social href=https://discord.com/users/1237543552733544559 rel=me> <img alt=discord src=https://ajafri2001.github.io/icons/social/discord.svg> </a></div></div><nav><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://ajafri2001.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://ajafri2001.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Typeclasses in Scala3<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2025-08-15</time> :: 4125 Words <span class=tags-label>:: Tags:</span><span class=tags> <a class=post-tag href=https://ajafri2001.github.io/tags/scala/>scala</a> , <a class=post-tag href=https://ajafri2001.github.io/tags/advanced/>advanced</a> , <a class=post-tag href=https://ajafri2001.github.io/tags/compile-time/>compile-time</a> , <a class=post-tag href=https://ajafri2001.github.io/tags/typelevel/>typelevel</a> </span></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://ajafri2001.github.io/posts/typeclasses/#introduction>Introduction</a><li><a href=https://ajafri2001.github.io/posts/typeclasses/#part-1-the-naive-oop-way>Part 1 - The Naive OOP Way</a><li><a href=https://ajafri2001.github.io/posts/typeclasses/#part-2-enter-typeclass>Part 2 - Enter Typeclass</a><li><a href=https://ajafri2001.github.io/posts/typeclasses/#part-3-typeclass-derivation>Part 3 - Typeclass derivation</a><li><a href=https://ajafri2001.github.io/posts/typeclasses/#conclusion>Conclusion</a></ul></div><section class=body><h2 id=introduction><a aria-label="Anchor link for: introduction" class=zola-anchor href=#introduction>Introduction</a></h2><p>There's not a whole lot of content that explains typeclasses in Scala well, especially from the point of why we should bother using them. Most concepts in functional programming aren't immediately obvious. As an example, it can be difficult to reason about why certain abstractions are useful when, in short snippets, they may look either terse or even boilerplate'ish code. In this article, I aim to provide some evidences of why typeclasses can be valuable and where they can be applied.<p>Let's assume we need to design a user-facing json library that exposes a clean and ergonomic API for serializing data. To this end will implement and compare three different ways to serialize JSON to a string in Scala.<p>For pragmatic reasons, we will design and serialize a JSON dialect that doesn’t necessarily adhere to the official specification, but it will be sufficient for our use case. We will start by modeling our type-level definitions (ADT's), which will subsequently compose into an AST that we will provide manually, and our interpreter will then convert it into a string. This blog isn’t a JSON parsing tutorial, so we won’t be covering that.<p>A spec of the <em><strong>values</strong></em> our JSON implementation will encode is as follows.<ul><li>Integer<li>String<li>Boolean<li>Null<li>Array<li>Object</ul><h2 id=part-1-the-naive-oop-way><a aria-label="Anchor link for: part-1-the-naive-oop-way" class=zola-anchor href=#part-1-the-naive-oop-way>Part 1 - The Naive OOP Way</a></h2><div class=note-container><div class=note-header><div class=note-icon><p>Assumptions</div></div><div class=note-content><p>This part assumes that you are familiar with the basic scala syntax and have some functional programming experience.</div></div><p>We'll start by modelling a trait <code>JsonExpression</code>, containing an abstract method that returns the string representation of the Json.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String
</span></code></pre><p>We then progressively add <code>JsonInt</code>, <code>JsonString</code>, <code>JsonBool</code> as case classes, and <code>JsonNull</code> as a singleton case object all of which extend the <code>JsonExpression</code> trait<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + value + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>" </span><span style=color:#5c6773;font-style:italic>// Json Strings are surrounded by quotes
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> JsonNull </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"null"
</span></code></pre><p>Now, that we have implemented 4 out of the 6 types, we will compose such simple types into more complex types such as <code>JsonArray</code> and <code>JsonObject</code> as follows -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> JsonArray</span><span>(</span><span style=color:#f29718>values</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>=</span><span> values</span><span style=color:#f29668>.</span><span>map(</span><span style=color:#39bae6;font-style:italic>_</span><span style=color:#f29668>.</span><span>stringify)</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>) 
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> JsonObject</span><span>(</span><span style=color:#f29718>values</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>= 
</span><span>    values
</span><span>      </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + value</span><span style=color:#f29668>.</span><span>stringify)
</span><span>      </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>We are finally done with modelling our JSON via an ADT ☺️,<p>Now before proceeding further let's build a very simple AST representing our ADT and evaluate it to verify it's functionality.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>val </span><span>expression: </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>  </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>    </span><span style=color:#c2d94c>"numbers"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(</span><span style=color:#f29668;font-style:italic>List</span><span>(</span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>1</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>2</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>3</span><span>)))</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#c2d94c>"strings"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(
</span><span>      </span><span style=color:#f29668;font-style:italic>List</span><span>(</span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#c2d94c>"a"</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#c2d94c>"b"</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#c2d94c>"c"</span><span>))
</span><span>    )
</span><span>  )
</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"numbers":[1,2,3],"strings":["a","b","c"]}
</span><span>println(expression</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>Congrats on reaching upto here, we hope you've been following along. Either on your local machine or on the interactive <a href=https://scastie.scala-lang.org/>scastie</a>. There's a lot more to come so buckle-up.<p>Now, let's assume we have some class and we wish to serialize it, say for example a class that models a person, i.e <code>class Person(name, age)</code>. How can we do it? One way of doing it is to simply extend the <code>JsonExpression</code> trait and implement it's <code>stringify</code> method, which would look like -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> Person</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>age</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>=
</span><span>    </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29668;font-style:italic>Map</span><span>(</span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(name)</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(age)))</span><span style=color:#f29668>.</span><span>stringify
</span><span>
</span><span style=color:#5c6773;font-style:italic>// We can now serialize the object to a Json string
</span><span style=color:#f73>val </span><span>person </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Bob"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>42</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"name":"Bob","age":42}
</span><span>println(person</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>Arguably, there's atleast two things that <em><strong>feel</strong></em> very wrong about this,<ol><li><p>There's very tight coupling between the <code>Person</code> class and the <code>JsonExpression</code> as evident by the implementation.</p><li><p>We're conceding the fact that <code>Person &lt;: JsonExpression</code> which doesn't feel natural at all. Ideally a data carrier shouldn't know how to serialize itself.</p></ol><p>Let's try to solve the above mentioned problems -<p>The first problem can be mitigated by not allowing users of the <code>JsonExpression</code> trait to extend it arbitrarily. In addition we can make the case classes <code>final</code> in scala to avoid it being extended as well. Scala offers the <code>sealed</code> keyword for traits, which prohibits extending the trait outside the compilation unit (i.e. outside the source file where it is defined).<p>Another benefit of this is that it allows the compiler to perform exhaustive checks at compile time for pattern matching. Because all subclasses of a sealed trait must be defined within the same compilation unit, the compiler knows the complete set of possible cases and can warn the developer if any case is not handled.<p>So let's add the <code>sealed</code> and <code>final</code> modifers on our traits and case classes respectively, So in the end, our code would look like this -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>sealed trait</span><span style=color:#59c2ff> JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String
</span><span>
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> JsonNull </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"null"
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>= </span><span style=color:#f07178>s</span><span style=color:#c2d94c>""""</span><span>$value</span><span style=color:#c2d94c>""""
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=
</span><span>    value</span><span style=color:#f29668>.</span><span>map(</span><span style=color:#39bae6;font-style:italic>_</span><span style=color:#f29668>.</span><span>stringify)</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>)
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value
</span><span>    </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + value</span><span style=color:#f29668>.</span><span>stringify)
</span><span>    </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>A way to solve the second problem i.e to <em>decouple</em> the classes from the serialization logic is to, basically do heuristics as such.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>def </span><span style=color:#ffb454>toJsonExpression</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Any</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span></code></pre><p>As we can tell from the signature itself, the method takes a <code>value: Any</code> and returns a <code>JsonExpression</code>, the implementation would look like this for some example classes.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#5c6773;font-style:italic>// Let's assume we need to serialize these data types
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Person</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>age</span><span>: </span><span style=color:#f73>Int</span><span>)
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> JobRole</span><span>(</span><span style=color:#f29718>id</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>applicants</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>])
</span><span>
</span><span style=color:#f73>def </span><span style=color:#ffb454>toJsonExpression</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Any</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=
</span><span>  value </span><span style=color:#f73>match
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#f29718>name</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>age</span><span>) </span><span style=color:#f73>=>
</span><span>      </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>        </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(name)</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=color:#c2d94c>"age"</span><span>  -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(age)
</span><span>      ))
</span><span>
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JobRole</span><span>(</span><span style=color:#f29718>id</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>applicants</span><span>) </span><span style=color:#f73>=>
</span><span>      </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>        </span><span style=color:#c2d94c>"id"</span><span>         -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(id)</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=color:#c2d94c>"applicants"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(applicants</span><span style=color:#f29668>.</span><span>map(toJsonExpression))
</span><span>      ))
</span><span>    
</span><span>    </span><span style=color:#f73>case </span><span style=color:#39bae6;font-style:italic>_ </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonNull </span><span style=color:#5c6773;font-style:italic>// Or throw some exception, since we defined a JsonNull might as well go with that
</span><span>
</span><span style=color:#f73>val </span><span>expression </span><span style=color:#f29668>=</span><span> toJsonExpression(
</span><span>  </span><span style=color:#f29668;font-style:italic>JobRole</span><span>(
</span><span>    </span><span style=color:#f29718>42</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#f29668;font-style:italic>List</span><span>(</span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Bob"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>52</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Steve"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>96</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"John"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>120</span><span>))
</span><span>  )
</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"id":42,"applicants":[{"name":"Bob","age":52},{"name":"Steve","age":96},{"name":"John","age":120}]}
</span><span>println(expression</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>On first glance this looks like a much cleaner alternative without either <code>Person</code> or <code>JobRole</code> subtyping into the <code>JsonExpression</code> trait, and for the most part it is.<p>It is certainly much better than our previous implementation where we employed subtyping.<p>Now, let's see the pain our library user has to go through -<ol><li><p>Huge lack of type-safety because of the signature containing <code>Any</code>. We can <em><strong>very</strong></em> easily pass innocent looking code which will result in a <code>ClassCastException</code> at runtime.</p><li><p>For every class that the user wishes to serialize, he has to painstakingly add additional serialization logic to the pattern match, which is already unsafe in the first place.</p></ol><p>With that, we're at the end of Part-1, and I hope you were able to make sense of it, we only used basic scala syntax and hopefully were able to make clear the pitfalls of the approach. Typeclasses in part-2 will allow us to write type-safe code.<h2 id=part-2-enter-typeclass><a aria-label="Anchor link for: part-2-enter-typeclass" class=zola-anchor href=#part-2-enter-typeclass>Part 2 - Enter Typeclass</a></h2><div class=note-container><div class=note-header><div class=note-icon><p>Assumptions</div></div><div class=note-content><p>This part assumes that you are familiar with Scala3's generics and <a href=https://docs.scala-lang.org/scala3/reference/contextual/>contextual abstractions</a>. Typeclasses in scala are <em>emulated</em> via <a href=https://docs.scala-lang.org/scala3/reference/contextual/givens.html>Given</a> and <a href=https://docs.scala-lang.org/scala3/reference/contextual/using-clauses.html>Using clauses</a>. It is best to learn/refresh those concepts as in this part we will employ the use of them quite heavily.</div></div><p>Alright, we've made it to the second part of the article, and before we introduce typeclasses we'd like to improve on our <code>JsonExpression</code> type, which currently looks like this -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>sealed trait</span><span style=color:#59c2ff> JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String
</span><span>
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> JsonNull </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"null"
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>= </span><span style=color:#f07178>s</span><span style=color:#c2d94c>""""</span><span>$value</span><span style=color:#c2d94c>""""
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=
</span><span>    value</span><span style=color:#f29668>.</span><span>map(</span><span style=color:#39bae6;font-style:italic>_</span><span style=color:#f29668>.</span><span>stringify)</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>)
</span><span>
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>override def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> value
</span><span>    </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + value</span><span style=color:#f29668>.</span><span>stringify)
</span><span>    </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>Even though the above is a valid ADT, it isn't a <em>pure value container</em>, as in the above snippet doesn't just carry data, it also carries the behavior which acts on the data. Let's refactor this and move the behavior outside the ADT and use pattern match to implement <code>stringify</code>.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>sealed trait</span><span style=color:#59c2ff> JsonExpression
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> JsonNull </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span>
</span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>(</span><span style=color:#f29718>json</span><span>: </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>): </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=
</span><span>  json </span><span style=color:#f73>match
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonNull          </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"null"
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f07178>s</span><span style=color:#c2d94c>""""</span><span>$value</span><span style=color:#c2d94c>""""
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>)    </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>)   </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>)  </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>map(stringify(</span><span style=color:#39bae6;font-style:italic>_</span><span>))</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>)
</span><span>    </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=>
</span><span>      value
</span><span>        </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + stringify(value))
</span><span>        </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>Here, we separated the behavior from our ADT, however this comes with a few DX (Developer Experience) drawbacks, notice that now you have to do <code>stringify(expression)</code> instead of <code>expression.stringify</code>, which easily becomes clunky as soon as you add more of those and start nesting them. To resolve this, we will use the Scala3 <code>extension</code> methods, so we rewrite the above as follows -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>sealed trait</span><span style=color:#59c2ff> JsonExpression
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> JsonNull </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span style=color:#f73>final case class</span><span style=color:#59c2ff> JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>]) </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>JsonExpression
</span><span>
</span><span>extension (json: </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>)
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=
</span><span>    json </span><span style=color:#f73>match
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonNull          </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"null"
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f07178>s</span><span style=color:#c2d94c>""""</span><span>$value</span><span style=color:#c2d94c>""""
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>)    </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>)   </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>)  </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>map(</span><span style=color:#39bae6;font-style:italic>_</span><span style=color:#f29668>.</span><span>stringify)</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>)
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=>
</span><span>        value
</span><span>          </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + value</span><span style=color:#f29668>.</span><span>stringify)
</span><span>          </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>This now looks pretty decent, however there's more that the scala compiler allows us to do. <code>sealed</code> traits and <code>final case</code> classes are in fact such a common pattern, that scala3 introduces new syntax sugar in the form of <code>enums</code> to define such <a href=https://docs.scala-lang.org/scala3/book/types-adts-gadts.html>ADT's</a> without the additional boilerplate. You would rewrite the above snippet as follows -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>enum </span><span style=color:#f29668;font-style:italic>JsonExpression</span><span>:
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonNull
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>)
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>)
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>)
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>])
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>])
</span><span>
</span><span style=color:#f29718>import </span><span style=color:#f29668;font-style:italic>JsonExpression</span><span>.*
</span><span>
</span><span style=color:#f29668;font-style:italic>extension </span><span>(</span><span style=color:#f29718>json</span><span>: </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>)
</span><span>  </span><span style=color:#f73>def </span><span style=color:#f29718>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span> =
</span><span>    </span><span style=color:#f29718>json </span><span style=color:#f73>match
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonNull          </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"null"
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f07178>s</span><span style=color:#c2d94c>""""</span><span>$value</span><span style=color:#c2d94c>""""</span><span> and start nesting them
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(</span><span style=color:#f29718>value</span><span>)    </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(</span><span style=color:#f29718>value</span><span>)   </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>toString
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(</span><span style=color:#f29718>value</span><span>)  </span><span style=color:#f73>=></span><span> value</span><span style=color:#f29668>.</span><span>map(</span><span style=color:#39bae6;font-style:italic>_</span><span style=color:#f29668>.</span><span>stringify)</span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"["</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"]"</span><span>)
</span><span>      </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(</span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=>
</span><span>        value
</span><span>          </span><span style=color:#f29668>.</span><span>map((</span><span style=color:#f29718>key</span><span>, </span><span style=color:#f29718>value</span><span>) </span><span style=color:#f73>=> </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>"</span><span> + key + </span><span style=color:#c2d94c>"</span><span style=color:#95e6cb>\"</span><span style=color:#c2d94c>:"</span><span> + value</span><span style=color:#f29668>.</span><span>stringify)
</span><span>          </span><span style=color:#f29668>.</span><span>mkString(</span><span style=color:#c2d94c>"{"</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>","</span><span style=color:#bfbab0cc>, </span><span style=color:#c2d94c>"}"</span><span>)
</span></code></pre><p>Now we have a well defined ADT and an extension method along with it which supplies the behavior to our types. With all that out of the way, we are now ready to get started with typeclasses, notice we didn't get into serializing custom classes like <code>Person</code> or <code>User</code> till now, I wanted to make sure that we setup a strong base and a clear intentional Sum-type ADT model instead of the boilerplate we had before.<p>Typeclasses are a way to achieve ad-hoc polymorphism that allows you write functions and APIs that work for many types, but without <em><strong>forcing</strong></em> those types into a common inheritance hierarchy. Instead, you define capabilities (in the form of traits) and provide implementations separately via given instances, often outside the type’s original definition.<p>They are a compile-time resolved, opt-in, non-invasive way of achieving polymorphism, where behavior is dispatched not by the object inheritance tree but by the presence of a given implementation in scope.<p>All in all, what a typeclass really requires is a generic trait and corresponding given instances that implement the capabilities for that trait.<p>Now, let's define a generic <code>JsonEncoder</code> trait -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span></code></pre><p>Now that we’ve defined the JsonEncoder trait, we can provide given instances for specific types. For example, for the <code>Person</code> type:<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f33>with
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span></code></pre><p>Note that when a trait accompanies a SAM (Single Abstract Method), Scala allows you to rewrite them as values as such -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>= 
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span></code></pre><p>We'll be using this so our code looks much neater and concise. With this capability in place, we can also define a generic method that works for any type <code>A</code> with <code>JsonEncoder</code> in scope.<p>Its signature would be -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>](</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span></code></pre><p>Note that this <code>using</code> clause requires a given instance of <code>JsonEncoder[A]</code> to be available in the scope.<div class=note-container><div class=note-header><div class=note-icon><p>Note</div></div><div class=note-content><p>Scala allows the use of haskell-like syntax instead of <code>using</code> via something called <a href=https://docs.scala-lang.org/scala3/book/ca-context-bounds.html><em><strong>context bounds</strong></em></a>, we won't be using this syntax in our article, but it's helpful to know if the syntax is found in the wild.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span style=color:#f29668>: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>](</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span></code></pre></div></div><p>Before implementing the method, we need a generic way to access the contextual <code>given</code> instance of <code>JsonEncoder[A]</code>. We do this by calling <code>summon</code> (or <code>implicitly</code> in Scala2), which directs the compiler to provide the appropriate instance from the current scope.<p>The implementation would look like this -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>](</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>= 
</span><span>  summon[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]]</span><span style=color:#f29668>.</span><span>encode(value)
</span></code></pre><p>Note that <code>summon[JsonEncoder[A]]</code> is simply a way to <em><strong>retrieve</strong></em> or <code>summon</code> the given instance so you can could <code>.encode</code> on it.<p>Now that we have implemented the <code>toJson</code> method, let's define one more given instance for the <code>JobRole</code> type and write out the typeclass we've created so far.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>= 
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class JobRole(id: Int, applicants: List[Person])
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>JobRole</span><span>] </span><span style=color:#f29668>=
</span><span>  (value: </span><span style=color:#39bae6;font-style:italic>JobRole</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=>
</span><span>    </span><span style=color:#39bae6;font-style:italic>JsonObject</span><span>(
</span><span>      </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>        </span><span style=color:#c2d94c>"id"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>id)</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=color:#c2d94c>"applicants"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(
</span><span>          value</span><span style=color:#f29668>.</span><span>applicants</span><span style=color:#f29668>.</span><span>map(summon[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>]]</span><span style=color:#f29668>.</span><span>encode)
</span><span>        )
</span><span>      )
</span><span>    )
</span><span>
</span><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>](</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]) </span><span style=color:#f29668>=
</span><span>  summon[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]]</span><span style=color:#f29668>.</span><span>encode(value)
</span><span>
</span><span style=color:#f73>val </span><span>jobRole </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>JobRole</span><span>(
</span><span>  </span><span style=color:#f29718>42</span><span style=color:#bfbab0cc>,
</span><span>  </span><span style=color:#f29668;font-style:italic>List</span><span>(</span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Bob"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>52</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Steve"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>96</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"John"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>120</span><span>))
</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"id":42,"applicants":[{"name":"Bob","age":52},{"name":"Steve","age":96},{"name":"John","age":120}]}
</span><span>println(toJson(jobRole)</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>In Scala, when we need a specific given instance, we often invoke <code>summon</code> at the call site. This can be avoided by naming the context parameter in the <code>using</code> clause, which allows us to treat it like a normal method parameter.<p>For example, instead of summoning the instance explicitly, we can define the method as -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>](</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using </span><span style=color:#f29718>jsonEncoder</span><span>: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>= 
</span><span>  jsonEncoder</span><span style=color:#f29668>.</span><span>encode(value)
</span></code></pre><p>Here, jsonEncoder is a named context parameter, so we can invoke its methods directly without explicitly summoning it.<p>Similarly, We can also name the <code>given</code> instances themselves. This makes them directly accessible in scope and easier to refer to when needed:<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>given personEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span></code></pre><p>With a named given like personEncoder, we can either let Scala resolve it implicitly or refer to it explicitly by name if we want to pass it around as a value.<p>Now after making these changes and making <code>toJson</code> an extension method while improving the user facing api, we end up with this -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>given personEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class JobRole(id: Int, applicants: List[Person])
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>JobRole</span><span>] </span><span style=color:#f29668>=
</span><span>  (value: </span><span style=color:#39bae6;font-style:italic>JobRole</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=>
</span><span>    </span><span style=color:#39bae6;font-style:italic>JsonObject</span><span>(
</span><span>      </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>        </span><span style=color:#c2d94c>"id"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>id)</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=color:#c2d94c>"applicants"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(
</span><span>          value</span><span style=color:#f29668>.</span><span>applicants</span><span style=color:#f29668>.</span><span>map(personEncoder</span><span style=color:#f29668>.</span><span>encode)
</span><span>        )
</span><span>      )
</span><span>    )
</span><span>
</span><span>extension [</span><span style=color:#39bae6;font-style:italic>A</span><span>](value: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using jsonEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>])
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>toJson </span><span>: </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=
</span><span>    jsonEncoder</span><span style=color:#f29668>.</span><span>encode(value)
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>= </span><span style=color:#5c6773;font-style:italic>// We define an additional method to improve the User API
</span><span>    toJson</span><span style=color:#f29668>.</span><span>stringify
</span></code></pre><p>Now let's take our typeclass for a spin, and see how we can use them -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>val </span><span>jobRole </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>JobRole</span><span>(
</span><span>  </span><span style=color:#f29718>42</span><span style=color:#bfbab0cc>,
</span><span>  </span><span style=color:#f29668;font-style:italic>List</span><span>(</span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Bob"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>52</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Steve"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>96</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"John"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>120</span><span>))
</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"id":42,"applicants":[{"name":"Bob","age":52},{"name":"Steve","age":96},{"name":"John","age":120}]}
</span><span>println(jobRole</span><span style=color:#f29668>.</span><span>toJson</span><span style=color:#f29668>.</span><span>stringify)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"id":42,"applicants":[{"name":"Bob","age":52},{"name":"Steve","age":96},{"name":"John","age":120}]}
</span><span>println(jobRole</span><span style=color:#f29668>.</span><span>stringify)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"name":"Steve","age":36}
</span><span>println(</span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Steve"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>36</span><span>)</span><span style=color:#f29668>.</span><span>stringify)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// JsonObject(Map(name -> JsonString(Links), age -> JsonInt(17)))
</span><span>println(</span><span style=color:#f29668;font-style:italic>Person</span><span>(</span><span style=color:#c2d94c>"Links"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>17</span><span>)</span><span style=color:#f29668>.</span><span>toJson)
</span></code></pre><p>The important part here is that we're able to use <code>.toJson</code> and <code>.stringify</code> without entering into any subtyping relationship, note that this isn't as seamless as we would like to be, we still have to define given instances for the types that need to be serialized, if the compiler can't find the given instances corresponding to the type requested, it will throw a compile-time error.<p>Now let's talk about what changed between this iteration and the version we wrote in Part-1<ol><li>We haven't entered into any subtyping relationship.<li>We now have very strong type guarantees.<li>We still have to manually provide <code>given</code> instances for our classes.</ol><p>The third point is addressed by typeclass derivation which we'll learn about in Part-3<h2 id=part-3-typeclass-derivation><a aria-label="Anchor link for: part-3-typeclass-derivation" class=zola-anchor href=#part-3-typeclass-derivation>Part 3 - Typeclass derivation</a></h2><div class=note-container><div class=note-header><div class=note-icon><p>Assumptions</div></div><div class=note-content><p>This part assumes that you are <em>very</em> comfortable with scala as well as familiar with Scala3's <code>inline</code> keyword and all the various places it can be used for example in pattern matching.</div></div><p>Congrats on making it to the final part! As a fellow learner, I’ll try to explain typeclass derivation the way I wish someone had explained to me a couple of months ago.<p>Before we get into typeclass derivation, I would like to talk a bit about Algebraic Data Types (ADT's).<p>They are primarily of two types<ul><li>Sum Types<li>Product Types</ul><p>We will first explore these and see what they mean.<p>In type theory and programming languages, Product types are types that combine multiple values into a single composite value, where each component is present and accessible whereas Sum types represent a choice between multiple alternatives, where exactly one of the possible variants is present at any given time.<p>More formally,<p>A product type $A × B$ is the cartesian product of types $A$ and $B$, meaning that a value of type $A × B$ is a pair $(a, b)$ where $a: A$ and $b: B$.<p>The simplest product types that you and I are familiar in scala are tuples!<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>(</span><span style=color:#c2d94c>"Shack"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>79</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>false</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case classes also count as product types
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Restaurant</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>address</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>zipcode</span><span>: </span><span style=color:#f73>Int</span><span>)
</span></code></pre><p>Conversely, a sum type $A + B$ is a type whose value is either an $A$ or a $B$, but not both at the same time.<p>Sum types in scala are primarily represented by <code>sealed traits</code> and <code>case classes</code> or in Scala3 <code>enums</code> as well.<div class=note-container><div class=note-header><div class=note-icon><p>Note</div></div><div class=note-content><p>You can convert <code>case classes</code> into tuples and vice versa via the <code>Mirror</code> typeclass. We'll talk about this later in this part since it is very useful to us.</div></div><pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>enum </span><span style=color:#f29668;font-style:italic>Shape</span><span>:
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>Square
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>Circle
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>Triangle
</span><span>
</span><span style=color:#5c6773;font-style:italic>// These also count as sum types
</span><span style=color:#f29718>sealed </span><span style=color:#f73>trait </span><span style=color:#f29668;font-style:italic>Shape
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> Square </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>Shape
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> Circle </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>Shape
</span><span style=color:#f73>case object</span><span style=color:#59c2ff> Triangle </span><span style=color:#f73>extends </span><span style=color:#59c2ff;text-decoration:underline>Shape
</span><span>
</span><span style=color:#5c6773;font-style:italic>// These as well but not suitable for our purposes so we'll not use these
</span><span style=color:#f73>type </span><span style=color:#59c2ff>Shape </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>Square | Circle | Triangle
</span></code></pre><p>Now that we discussed this, let's come back to code land.<p>Let's take a look at the <code>JsonEncoder[Person]</code> given instance<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>given personEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span></code></pre><p>The above example requires us to hardcode the "labels" for each case class, as evident by the <code>"name"</code> and <code>"age"</code>, If you've used a java json library like Gson before, you'd know that you don't really need to care about the field names or labels of your object, you can most of the time just hand in the object, and the library can find the field names via reflection at runtime and proceed to serialize the data.<p>However, this method breaks type-safety as the compiler has no way to know what's being accessed, invoked or being casted, therefore it is unable to guarantee any correctness.<p>What we need is a way to preserve type-safety at compile-time and not having to write the boilerplate of multiple <code>given</code> instances for each and every possible case class we wish to serialize. This is accomplished via typeclass derivation.<p><em><strong>Typeclass derivation is a way to automatically synthesize <code>given</code> instances for our typeclasses instead of providing it ourselves.</strong></em><p>To solve this and other similar problems, Scala 3’s metaprogramming features allow compile-time inspection of a type’s structure, including field names and types. This enables generating serializers that adapt to a case class definition without hardcoding any labels (as we did in the above <code>given</code> instance), preserving type safety and avoiding runtime penalty via reflection.<p>Metaprogramming techniques in scala primarily fall in two categories -<ol><li>Typelevel Computations<li>Macros</ol><p>We will primarily focus on typelevel computations in this blog, the goal is also accomplished via Scala <a href=https://docs.scala-lang.org/scala3/guides/macros/macros.html>macros</a> but among other things I do not have sufficient confidence to write about it at this time.<p>Scala3's standard library includes a typeclass <code>Mirror</code> in the <code>scala.deriving</code> package that provides <em>compile-time reflection</em> specifically for Product and Sum types.<p>Quoting the <a href=https://www.scala-lang.org/api/current/scala/deriving/Mirror.html>documentation</a>, <em><strong>Mirrors allows typelevel access to enums, case classes and objects, and their sealed parents.</strong></em> Reading the documentation is highly recommended as well as poking through the <a href=https://github.com/scala/scala3/blob/3.7.2/library/src/scala/deriving/Mirror.scala#L5>source code</a>.<p>Let's try to play around with the library before jumping into the derivation part.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>import</span><span> deriving</span><span style=color:#f29668>.</span><span>Mirror
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>fiction</span><span>: </span><span style=color:#f73>Boolean</span><span>)
</span><span>
</span><span>enum </span><span style=color:#f29668;font-style:italic>Bool</span><span>:
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>True
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>False
</span></code></pre><p>Here, we imported <code>Mirror</code> and defined a product type case class called <code>Book</code> and a sum type enum called <code>Bool</code>. This time we'll be working and playing around with the <code>Mirror</code> typeclass to get a feel for what it can do.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>import</span><span> deriving</span><span style=color:#f29668>.</span><span>Mirror
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>fiction</span><span>: </span><span style=color:#f73>Boolean</span><span>)
</span><span>
</span><span>enum </span><span style=color:#f29668;font-style:italic>Bool</span><span>:
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>True
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>False
</span><span>
</span><span style=color:#5c6773;font-style:italic>// This is how we use Mirror
</span><span style=color:#f29718>val bookMirror</span><span> = </span><span style=color:#f29718>summon</span><span>[</span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>Of</span><span>[</span><span style=color:#39bae6;font-style:italic>Book</span><span>]]
</span><span style=color:#f29718>val boolMirror</span><span> = </span><span style=color:#f29718>summon</span><span>[</span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>Of</span><span>[</span><span style=color:#39bae6;font-style:italic>Bool</span><span>]]
</span></code></pre><p>The types of <code>bookMirror</code> and <code>boolMirror</code> encode various typelevel information about the ADT's. Here's what there string representation looks like -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#5c6773;font-style:italic>// Note that the compiler is automatically able to infer whether these are sum types or product types
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class Book(name: String, pages: Int, fiction: Boolean)
</span><span style=color:#f29668;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#f29668;font-style:italic>Product </span><span>{
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredMonoType </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>Book</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredType </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>Book</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredLabel </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"Book"</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredElemTypes </span><span style=color:#f29668>= </span><span>(</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f73>Boolean</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredElemLabels </span><span style=color:#f29668>= </span><span>("</span><span style=color:#39bae6;font-style:italic>name</span><span>"</span><span style=color:#bfbab0cc>,</span><span> "</span><span style=color:#39bae6;font-style:italic>pages</span><span>"</span><span style=color:#bfbab0cc>,</span><span> "</span><span style=color:#39bae6;font-style:italic>fiction</span><span>")
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>// enum Bool: case True, False
</span><span style=color:#f29668;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#f29668;font-style:italic>Sum </span><span>{
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredMonoType </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>Bool</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredType </span><span style=color:#f29668>= </span><span style=color:#39bae6;font-style:italic>Bool</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredLabel </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"Bool"</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredElemTypes </span><span style=color:#f29668>= </span><span>(</span><span style=color:#39bae6;font-style:italic>Bool</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>True</span><span style=color:#f29668>.</span><span style=color:#f73>type</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>Bool</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>False</span><span style=color:#f29668>.</span><span style=color:#f73>type</span><span>)</span><span style=color:#bfbab0cc>;
</span><span>  </span><span style=color:#f73>type </span><span style=color:#59c2ff>MirroredElemLabels </span><span style=color:#f29668>= </span><span>("</span><span style=color:#39bae6;font-style:italic>True</span><span>"</span><span style=color:#bfbab0cc>,</span><span> "</span><span style=color:#39bae6;font-style:italic>False</span><span>")
</span><span>}
</span></code></pre><p>Now, to convert these type-level entities to actual values we can use and manipulate, we need an additional import of <code>compiletime.*</code> which allows us a bunch of useful imports like <code>erasedValue</code>, <code>constValue</code>, <code>constValueTuple</code>, <code>summonInline</code> which we'll discuss later.<p>To achieve our goal of Json serializing, we will need to care about <em><strong>ALL</strong></em> of these.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>import</span><span> compiletime</span><span style=color:#f29668>.</span><span>{constValue</span><span style=color:#bfbab0cc>,</span><span> constValueTuple}
</span><span style=color:#f73>import</span><span> deriving</span><span style=color:#f29668>.</span><span>Mirror
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>fiction</span><span>: </span><span style=color:#f73>Boolean</span><span>)
</span><span>
</span><span>enum </span><span style=color:#f29668;font-style:italic>Bool</span><span>:
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>True
</span><span>  </span><span style=color:#f73>case </span><span style=color:#f29668;font-style:italic>False
</span><span>
</span><span style=color:#5c6773;font-style:italic>// This is how we use Mirror
</span><span style=color:#f29718>val bookMirror</span><span> = </span><span style=color:#f29718>summon</span><span>[</span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>Of</span><span>[</span><span style=color:#39bae6;font-style:italic>Book</span><span>]]
</span><span style=color:#f29718>val boolMirror</span><span> = </span><span style=color:#f29718>summon</span><span>[</span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>Of</span><span>[</span><span style=color:#39bae6;font-style:italic>Bool</span><span>]]
</span><span>
</span><span style=color:#5c6773;font-style:italic>// Get the name of the labels of the class
</span><span style=color:#f29718>val bookMirrorLabels</span><span>: (</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>String</span><span>) = </span><span style=color:#f29718>constValueTuple</span><span>[</span><span style=color:#39bae6;font-style:italic>bookMirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>]
</span><span style=color:#f29718>val boolMirrorLabels</span><span>: (</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>String</span><span>) = </span><span style=color:#f29718>constValueTuple</span><span>[</span><span style=color:#39bae6;font-style:italic>boolMirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>]
</span><span>
</span><span style=color:#5c6773;font-style:italic>// ("name", "pages", "fiction")
</span><span style=color:#f29668;font-style:italic>println</span><span>(</span><span style=color:#f29718>bookMirrorLabels</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// ("True", "False")
</span><span style=color:#f29668;font-style:italic>println</span><span>(</span><span style=color:#f29718>boorMirrorLabels</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// To get a single value label instead of a Tuple, we can use
</span><span>
</span><span style=color:#5c6773;font-style:italic>//"Book"
</span><span style=color:#f29718>val bookMirrorLabel</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span> = </span><span style=color:#f29718>constValue</span><span>[</span><span style=color:#39bae6;font-style:italic>bookMirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredLabel</span><span>]
</span><span>
</span><span style=color:#5c6773;font-style:italic>//"Bool"
</span><span style=color:#f29718>val boolMirrorLabel</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span> = </span><span style=color:#f29718>constValue</span><span>[</span><span style=color:#39bae6;font-style:italic>boolMirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredLabel</span><span>]
</span></code></pre><p>Now that we have concrete values of our ADT's, this is a good moment to discuss how typeclass derivation actually works.<p>Typeclass derivation works by destructuring complex types which do not yet have <code>given</code> instances provided for them, to simpler types which do have <code>given</code> instances provided for them. As an example consider how the <code>Book</code> type consists of (String, Int, Boolean).<p>To derive a given instance for the said <code>Book</code> type, the compiler recursively decomposes it into its constituent types, String, Int, and Boolean, and verifies that given instances exist for each component, or that the types are themselves derivable. This recursive decomposition allows the derivation mechanism to systematically reduce complex types to simpler types with the available given instances.<p>Now, let us recall our <code>JsonEncoder</code> typeclass we wrote in Part-2 -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class Person(name: String, age: Int)
</span><span>given personEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Person</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>Person</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>      </span><span style=color:#c2d94c>"name"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value</span><span style=color:#f29668>.</span><span>name)</span><span style=color:#bfbab0cc>,
</span><span>      </span><span style=color:#c2d94c>"age"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>age)
</span><span>    )
</span><span>  )
</span><span>
</span><span style=color:#5c6773;font-style:italic>// case class JobRole(id: Int, applicants: List[Person])
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>JobRole</span><span>] </span><span style=color:#f29668>=
</span><span>  (value: </span><span style=color:#39bae6;font-style:italic>JobRole</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=>
</span><span>    </span><span style=color:#39bae6;font-style:italic>JsonObject</span><span>(
</span><span>      </span><span style=color:#f29668;font-style:italic>Map</span><span>(
</span><span>        </span><span style=color:#c2d94c>"id"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value</span><span style=color:#f29668>.</span><span>id)</span><span style=color:#bfbab0cc>,
</span><span>        </span><span style=color:#c2d94c>"applicants"</span><span> -> </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(
</span><span>          value</span><span style=color:#f29668>.</span><span>applicants</span><span style=color:#f29668>.</span><span>map(personEncoder</span><span style=color:#f29668>.</span><span>encode)
</span><span>        )
</span><span>      )
</span><span>    )
</span></code></pre><p>In here, we do not need the <code>given</code> instances for <code>JobRole</code> or for <code>Person</code> case classes, we would like to derive them ourselves, so instead of that, let us provide some <em>primitive</em> <code>given</code> instances, which can be used by the compiler to <em>construct</em> the <code>given</code> instances for complex types sunce as <code>JobRole</code> or <code>Person</code>.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Int</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value)
</span><span>
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value)
</span><span>
</span><span>given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Boolean</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(value)
</span></code></pre><p>Now that we have defined the <code>given</code> instances for <code>JsonEncoder[A]</code>, we'll first refactor the <code>given</code> instances in the companion object for <code>JsonEncoder</code>. The reasons for this will be explained later apart from being idiomatic in general.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#f73>object</span><span style=color:#59c2ff> JsonEncoder</span><span>:
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Int</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Boolean</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(value)
</span></code></pre><p>Additionally we'll define an <code>inline</code> method in the companion object called <code>derived</code> with the following signature. The naming is important and will also be explained later -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]
</span></code></pre><p>This looks a bit cryptic, so let's go over it,<ul><li>The reason for the constraint <code>A &lt;: Product</code> is that every case class in a <code>sealed</code> trait heirarchy, as well as tuples automatically extend the <code>Product</code> trait. More information can be found <a href=https://www.scala-lang.org/api/current/scala/Product.html>here</a><li>The reason for using <code>mirror: Mirror.ProductOf[A]</code>, is that so we can extract the labels, types and eventually process them into a JsonEncoder[A].</ul><p>We begin the implementation by converting our case class into a tuple. This is done using <code>Tuple.fromProductTyped</code>, which takes a case class instance and produces a corresponding tuple.<p>The advantage of using a tuple is that we can easily destructure it into head and tail elements, similar to how we handle lists, using the <code>*:</code> operator. This enables us to pattern match on it recursively.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>    </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>    </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>= </span><span style=color:#f73>???
</span></code></pre><p>Now that we have some abstract implementation for the <code>derived</code> method, the next step is to extract the field labels of the tuple and determine their types. These types can be directly defined, or be eventually deconstructed to.<p>For example, consider the <code>case class Person(name: String, age: Int)</code> and the instance <code>Person("Bob", 42)</code>.<p>We start by converting the <code>Person</code> instance into a tuple of values: <code>("Bob", 42)</code>. Using the <code>Mirror.ProductOf[A]</code> typeclass, we already have access to the field labels and types via <code>mirror.MirroredElemLabels</code> and <code>mirror.MirroredElemTypes</code>. With this, we have three vital pieces of information:<ol><li>Labels: <code>("name", "age")</code><li>Types: <code>(String, Int)</code><li>Values: <code>("Bob", 42)</code></ol><p>We can now recurse over these in parallel to construct a <code>Map[String, JsonExpression]</code>. Here, the <code>String</code> are the field labels, and the <code>JsonExpression</code> are the values which are obtained by dispatching to the primitive <code>given</code> instances we defined earlier, such as <code>JsonEncoder[Int]</code>, <code>JsonEncoder[String]</code>, and <code>JsonEncoder[Boolean]</code>.<p>Hope all this made sense.<p>At this stage, we can implement the signature of a helper inline method, which will be delegated to for handling the processing<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>processTupless</span><span>[</span><span style=color:#39bae6;font-style:italic>E </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>L </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span>](</span><span style=color:#f29718>elements</span><span>: </span><span style=color:#39bae6;font-style:italic>E</span><span>): </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>] </span><span style=color:#f29668>= </span><span style=color:#f73>???
</span><span>
</span><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>    </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>    </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>= 
</span><span>      processTuples[</span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemTypes</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>](
</span><span>        valueTuple
</span><span>      )
</span><span>    </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(mapRepresentation)
</span></code></pre><p>Let's go over <code>processTuples</code>'s type signature -<ol><li><p>The <code>&lt;: Tuple</code> bound ensures that <code>E</code> and <code>L</code> are a tuple type, so we can safely destructure them recursively using <code>*:</code> in pattern matching:</p><li><p><code>E &lt;: Tuple</code> represents the type of the tuple of <em><strong>values</strong></em> from the case class instance which we supply manually in <code>derived</code> via <code>mirror.MirroredElemTypes</code>.</p><li><p><code>L &lt;: Tuple</code> represents the tuple of field labels from the <code>Mirror.ProductOf[A]</code> which we supply manually in <code>derived</code> via <code>mirror.MirroredElemLabels</code>.</p><li><p><code>elements: E</code> represent the the runtime tuple of values, e.g. <code>("Bob", 42)</code></p></ol><p>Now that this is hopefully clear, we can partially complete it's implementation -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>processTuples</span><span>[</span><span style=color:#39bae6;font-style:italic>E </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>L </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span>](</span><span style=color:#f29718>elements</span><span>: </span><span style=color:#39bae6;font-style:italic>E</span><span>): </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>] </span><span style=color:#f29668>=
</span><span>  inline (elements</span><span style=color:#bfbab0cc>,</span><span> erasedValue[</span><span style=color:#39bae6;font-style:italic>L</span><span>]) </span><span style=color:#f73>match
</span><span>    </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>Map</span><span style=color:#f29668>.</span><span>empty
</span><span>    </span><span style=color:#f73>case</span><span> ...
</span><span>
</span><span style=color:#f29718>inline </span><span style=color:#f73>def </span><span style=color:#f29718>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span> &lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](</span><span style=color:#f29718>using mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] =
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>    </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>    </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>= 
</span><span>      processTuples[</span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemTypes</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>](
</span><span>        valueTuple
</span><span>      )
</span><span>    </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(mapRepresentation)
</span></code></pre><p>We introduced a new keyword <code>erasedValue</code>.<ul><li><a href=https://docs.scala-lang.org/scala3/reference/metaprogramming/compiletime-ops.html#erasedvalue>erasedValue</a> allows types to be treated as values at compile time. Normally, types exist only in the type system and cannot be pattern matched on directly. <code>erasedValue[T]</code> provides a placeholder value for a type T that can be used in an inline match.</ul><p>Note that you can only use <code>erasedValue</code> at compile time and with an <code>inline</code> match.<p>Now we can complete the implementation as follows -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>processTuples</span><span>[</span><span style=color:#39bae6;font-style:italic>E </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>L </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span>](
</span><span>      </span><span style=color:#f29718>elements</span><span>: </span><span style=color:#39bae6;font-style:italic>E
</span><span>  ): </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>] </span><span style=color:#f29668>=
</span><span>    inline (elements</span><span style=color:#bfbab0cc>,</span><span> erasedValue[</span><span style=color:#39bae6;font-style:italic>L</span><span>]) </span><span style=color:#f73>match
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>Map</span><span style=color:#f29668>.</span><span>empty
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29718>ele</span><span>: (</span><span style=color:#39bae6;font-style:italic>eleHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>eleTail</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>lab</span><span>: (</span><span style=color:#39bae6;font-style:italic>labelHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>)) </span><span style=color:#f73>=>
</span><span>        </span><span style=color:#f73>val </span><span>(head *: tail) </span><span style=color:#f29668>=</span><span> ele
</span><span>        </span><span style=color:#f73>val </span><span>label </span><span style=color:#f29668>=</span><span> constValue[</span><span style=color:#39bae6;font-style:italic>labelHead</span><span>]
</span><span>        </span><span style=color:#f73>val </span><span>value </span><span style=color:#f29668>=</span><span> summonInline[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>eleHead</span><span>]]</span><span style=color:#f29668>.</span><span>encode(head)
</span><span>        processTuples[</span><span style=color:#39bae6;font-style:italic>eleTail</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>](tail) + (</span><span style=color:#c2d94c>""</span><span> + label -> value)
</span><span>
</span><span>inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] </span><span style=color:#f29668>=
</span><span>  (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>    </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>    </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>= 
</span><span>      processTuples[</span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemTypes</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>](
</span><span>        valueTuple
</span><span>      )
</span><span>    </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(mapRepresentation)
</span></code></pre><p>This is a bit terse, but soon it'll become intuitive as it's not too conceptually different from when we process regular Lists instead of Tuples.<ul><li><a href=https://docs.scala-lang.org/scala3/reference/metaprogramming/compiletime-ops.html#summoninline>summonInline</a> is basically the same as regular <code>summon</code> except that it's execution is delayed until after the method get inlined at the callsite thereby changing it's scope.</ul><p>What we're doing here, is processing the two tuples in parallel and recursively putting them into a <code>Map[String, JsonExpression]</code>, where each <code>head</code> of a tuple contains exactly one element which we then <code>summonInline</code> on, and we keep recursively dispatching the heads to their predefined <code>given</code> instances as seen in <code>summonInline[JsonEncoder[eleHead]].encode(head)</code>. After we're finished processing them we finally get to the base case and then return our newly constructed map.<p>Hope this was well explained.<p>Now, let's look our implemented <code>JsonEncoder</code> typeclass -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#f73>object</span><span style=color:#59c2ff> JsonEncoder</span><span>:
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Int</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Boolean</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(value)
</span><span>
</span><span>  inline </span><span style=color:#f73>def </span><span style=color:#ffb454>processTuples</span><span>[</span><span style=color:#39bae6;font-style:italic>E </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>L </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span>](
</span><span>      </span><span style=color:#f29718>elements</span><span>: </span><span style=color:#39bae6;font-style:italic>E
</span><span>  ): </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>] </span><span style=color:#f29668>=
</span><span>    inline (elements</span><span style=color:#bfbab0cc>,</span><span> erasedValue[</span><span style=color:#39bae6;font-style:italic>L</span><span>]) </span><span style=color:#f73>match
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>Map</span><span style=color:#f29668>.</span><span>empty
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29718>ele</span><span>: (</span><span style=color:#39bae6;font-style:italic>eleHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>eleTail</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>lab</span><span>: (</span><span style=color:#39bae6;font-style:italic>labelHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>)) </span><span style=color:#f73>=>
</span><span>        </span><span style=color:#f73>val </span><span>(head *: tail) </span><span style=color:#f29668>=</span><span> ele
</span><span>        </span><span style=color:#f73>val </span><span>label </span><span style=color:#f29668>=</span><span> constValue[</span><span style=color:#39bae6;font-style:italic>labelHead</span><span>]
</span><span>        </span><span style=color:#f73>val </span><span>value </span><span style=color:#f29668>=</span><span> summonInline[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>eleHead</span><span>]]</span><span style=color:#f29668>.</span><span>encode(head)
</span><span>        processTuples[</span><span style=color:#39bae6;font-style:italic>eleTail</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>](tail) + (</span><span style=color:#c2d94c>""</span><span> + label -> value)
</span><span>
</span><span>  inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using
</span><span>      </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]
</span><span>  ): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] </span><span style=color:#f29668>=
</span><span>    (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>      </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>      </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>=
</span><span>        processTuples[</span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemTypes</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>](
</span><span>          valueTuple
</span><span>        )
</span><span>      </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(mapRepresentation)
</span></code></pre><p>We can now use it as follows -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>read</span><span>: </span><span style=color:#f73>Boolean</span><span>)
</span><span>
</span><span style=color:#f73>val </span><span>book </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Book</span><span>(</span><span style=color:#c2d94c>"Harry Potter"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>300</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>false</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// JsonObject(Map(read -> JsonBool(true), age -> JsonInt(42), name -> JsonString(JOB)))
</span><span style=color:#f73>val </span><span>jsonStructure: </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span style=color:#f29668>.</span><span>derived[</span><span style=color:#39bae6;font-style:italic>Book</span><span>]</span><span style=color:#f29668>.</span><span>encode(book)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"read":true,"age":42,"name":"JOB"}
</span><span>println(jsonStructure</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>As we can see, we have automatically derived the <code>given</code> instance at compile time, and this would work for <em><strong>ANY</strong></em> case class that can eventually decompose into some combination of either <code>String</code>, <code>Boolean</code>, <code>Int</code> which we provided before.<p>We can also extend it to include <code>List[A]</code> but let's first talk about a convenient feature that Scala3 offers us, i.e the <code>derives</code> clause.<p>Recall how we moved the <code>given</code> instances and the <code>inline</code> methods under the companion object of the <code>JsonEncoder</code> trait. This was done for reasons I will explain now -<p>If within a companion object of a typeclass contains a <code>derived</code> method, it has a special meaning not unlike <code>toString</code>, <code>apply</code>, <code>unapply</code> etc. It allows us to annotate our case classes with derives as such.<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>read</span><span>: </span><span style=color:#f73>Boolean</span><span>) derives </span><span style=color:#f29668;font-style:italic>JsonEncoder
</span></code></pre><p>This allows us to directly summon the <code>given</code> instances as if it was already defined as such -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>read</span><span>: </span><span style=color:#f73>Boolean</span><span>) derives </span><span style=color:#f29668;font-style:italic>JsonEncoder
</span><span>
</span><span style=color:#f73>val </span><span>book </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Book</span><span>(</span><span style=color:#c2d94c>"Harry Potter"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>300</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>false</span><span>)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// JsonObject(Map(read -> JsonBool(true), age -> JsonInt(42), name -> JsonString(JOB)))
</span><span style=color:#f73>val </span><span>jsonStructure: </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=</span><span> summon[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>Book</span><span>]]</span><span style=color:#f29668>.</span><span>encode(book)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"read":true,"age":42,"name":"JOB"}
</span><span>println(jsonStructure</span><span style=color:#f29668>.</span><span>stringify)
</span></code></pre><p>Let's bring the extension method we wrote in Part - 2 to take care of the boilerplate of summoning instances, as well as provide the <code>JsonEncoder[List[A]]</code><pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>trait</span><span style=color:#59c2ff> JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]:
</span><span>  </span><span style=color:#f73>def </span><span style=color:#ffb454>encode</span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>): </span><span style=color:#39bae6;font-style:italic>JsonExpression
</span><span>
</span><span style=color:#f73>object</span><span style=color:#59c2ff> JsonEncoder</span><span>:
</span><span>  extension [</span><span style=color:#39bae6;font-style:italic>A</span><span>](value: </span><span style=color:#39bae6;font-style:italic>A</span><span>)(using jsonEncoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>])
</span><span>    </span><span style=color:#f73>def </span><span style=color:#ffb454>toJson</span><span>: </span><span style=color:#39bae6;font-style:italic>JsonExpression </span><span style=color:#f29668>=
</span><span>      jsonEncoder</span><span style=color:#f29668>.</span><span>encode(value)
</span><span>    </span><span style=color:#f73>def </span><span style=color:#ffb454>stringify</span><span>: </span><span style=color:#39bae6;font-style:italic>String </span><span style=color:#f29668>=</span><span> toJson</span><span style=color:#f29668>.</span><span>stringify
</span><span>
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Int</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Int</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonInt</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonString</span><span>(value)
</span><span>  given </span><span style=color:#f29668;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#f73>Boolean</span><span>] </span><span style=color:#f29668>= </span><span>(</span><span style=color:#f29718>value</span><span>: </span><span style=color:#f73>Boolean</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>JsonBool</span><span>(value)
</span><span>
</span><span>  given [</span><span style=color:#39bae6;font-style:italic>A</span><span>](using encoder: </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]] </span><span style=color:#f29668>=
</span><span>    (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]) </span><span style=color:#f73>=>
</span><span>      </span><span style=color:#f29668;font-style:italic>JsonArray</span><span>(
</span><span>        value</span><span style=color:#f29668>.</span><span>map(encoder</span><span style=color:#f29668>.</span><span>encode)
</span><span>      )
</span><span>
</span><span>  inline </span><span style=color:#f73>def </span><span style=color:#ffb454>jsonTuple</span><span>[</span><span style=color:#39bae6;font-style:italic>E </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>L </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Tuple</span><span>](
</span><span>      </span><span style=color:#f29718>elements</span><span>: </span><span style=color:#39bae6;font-style:italic>E
</span><span>  ): </span><span style=color:#39bae6;font-style:italic>Map</span><span>[</span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>JsonExpression</span><span>] </span><span style=color:#f29668>=
</span><span>    inline (elements</span><span style=color:#bfbab0cc>,</span><span> erasedValue[</span><span style=color:#39bae6;font-style:italic>L</span><span>]) </span><span style=color:#f73>match
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span style=color:#bfbab0cc>, </span><span style=color:#f29668;font-style:italic>EmptyTuple</span><span>) </span><span style=color:#f73>=> </span><span style=color:#f29668;font-style:italic>Map</span><span style=color:#f29668>.</span><span>empty
</span><span>      </span><span style=color:#f73>case </span><span>(</span><span style=color:#f29718>ele</span><span>: (</span><span style=color:#39bae6;font-style:italic>eleHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>eleTail</span><span>)</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>lab</span><span>: (</span><span style=color:#39bae6;font-style:italic>labelHead *</span><span>: </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>)) </span><span style=color:#f73>=>
</span><span>        </span><span style=color:#f73>val </span><span>(head *: tail) </span><span style=color:#f29668>=</span><span> ele
</span><span>        </span><span style=color:#f73>val </span><span>label </span><span style=color:#f29668>=</span><span> constValue[</span><span style=color:#39bae6;font-style:italic>labelHead</span><span>]
</span><span>        </span><span style=color:#f73>val </span><span>value </span><span style=color:#f29668>=</span><span> summonInline[</span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>eleHead</span><span>]]</span><span style=color:#f29668>.</span><span>encode(head)
</span><span>        jsonTuple[</span><span style=color:#39bae6;font-style:italic>eleTail</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>labelTail</span><span>](tail) + (</span><span style=color:#c2d94c>""</span><span> + label -> value)
</span><span>
</span><span>  inline </span><span style=color:#f73>def </span><span style=color:#ffb454>derived</span><span>[</span><span style=color:#39bae6;font-style:italic>A </span><span style=color:#f29668>&lt;: </span><span style=color:#39bae6;font-style:italic>Product</span><span>](using
</span><span>      </span><span style=color:#f29718>mirror</span><span>: </span><span style=color:#39bae6;font-style:italic>Mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>ProductOf</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>]
</span><span>  ): </span><span style=color:#39bae6;font-style:italic>JsonEncoder</span><span>[</span><span style=color:#39bae6;font-style:italic>A</span><span>] </span><span style=color:#f29668>=
</span><span>    (</span><span style=color:#f29718>value</span><span>: </span><span style=color:#39bae6;font-style:italic>A</span><span>) </span><span style=color:#f73>=>
</span><span>      </span><span style=color:#f73>val </span><span>valueTuple </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Tuple</span><span style=color:#f29668>.</span><span>fromProductTyped(value)
</span><span>      </span><span style=color:#f73>val </span><span>mapRepresentation </span><span style=color:#f29668>=
</span><span>        jsonTuple[</span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemTypes</span><span style=color:#bfbab0cc>, </span><span style=color:#39bae6;font-style:italic>mirror</span><span style=color:#f29668>.</span><span style=color:#39bae6;font-style:italic>MirroredElemLabels</span><span>](
</span><span>          valueTuple
</span><span>        )
</span><span>      </span><span style=color:#f29668;font-style:italic>JsonObject</span><span>(mapRepresentation)
</span></code></pre><p>And.... there you go! We have successfully created our own very ergonomic, typesafe, json serializing library :P.<p>We can take a look for ourselves how easy and intuitive it is -<pre class=language-scala data-lang=scala style=color:#bfbab0;background-color:#0f1419><code class=language-scala data-lang=scala><span style=color:#f73>case class</span><span style=color:#59c2ff> Book</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>pages</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>read</span><span>: </span><span style=color:#f73>Boolean</span><span>) derives </span><span style=color:#f29668;font-style:italic>JsonEncoder
</span><span>
</span><span style=color:#f73>case class</span><span style=color:#59c2ff> Library</span><span>(</span><span style=color:#f29718>name</span><span>: </span><span style=color:#39bae6;font-style:italic>String</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>zipcode</span><span>: </span><span style=color:#f73>Int</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>books</span><span>: </span><span style=color:#39bae6;font-style:italic>List</span><span>[</span><span style=color:#39bae6;font-style:italic>Book</span><span>]) derives </span><span style=color:#f29668;font-style:italic>JsonEncoder
</span><span>
</span><span style=color:#f73>val </span><span>library </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>Library</span><span>(
</span><span>  name </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"Central Library"</span><span style=color:#bfbab0cc>,
</span><span>  zipcode </span><span style=color:#f29668>= </span><span style=color:#f29718>12345</span><span style=color:#bfbab0cc>,
</span><span>  books </span><span style=color:#f29668>= </span><span style=color:#f29668;font-style:italic>List</span><span>(
</span><span>    </span><span style=color:#f29668;font-style:italic>Book</span><span>(</span><span style=color:#c2d94c>"1984"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>328</span><span style=color:#bfbab0cc>,</span><span> read </span><span style=color:#f29668>= </span><span style=color:#f29718>true</span><span>)</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#f29668;font-style:italic>Book</span><span>(</span><span style=color:#c2d94c>"Brave New World"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>268</span><span style=color:#bfbab0cc>,</span><span> read </span><span style=color:#f29668>= </span><span style=color:#f29718>false</span><span>)</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#f29668;font-style:italic>Book</span><span>(</span><span style=color:#c2d94c>"Fahrenheit 451"</span><span style=color:#bfbab0cc>, </span><span style=color:#f29718>194</span><span style=color:#bfbab0cc>,</span><span> read </span><span style=color:#f29668>= </span><span style=color:#f29718>true</span><span>)
</span><span>  )
</span><span>)
</span><span style=color:#5c6773;font-style:italic>// {"books":[{"read":true,"pages":328,"name":"1984"},{"read":false,"pages":268,"name":"Brave New World"}, {"read":true,"pages":194,"name":"Fahrenheit 451"}],"zipcode":12345,"name":"Central Library"}
</span><span>println(library</span><span style=color:#f29668>.</span><span>stringify)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// JsonObject(Map(books -> JsonArray(List(JsonObject(Map(read -> JsonBool(true), pages -> JsonInt(328), name -> JsonString(1984))), JsonObject(Map(read -> JsonBool(false), pages -> JsonInt(268), name -> JsonString(Brave New World))), JsonObject(Map(read -> JsonBool(true), pages -> JsonInt(194), name -> JsonString(Fahrenheit 451))))), zipcode -> JsonInt(12345), name -> JsonString(Central Library)))
</span><span>println(library</span><span style=color:#f29668>.</span><span>toJson)
</span><span>
</span><span style=color:#5c6773;font-style:italic>// {"books":[{"read":true,"pages":328,"name":"1984"},{"read":false,"pages":268,"name":"Brave New World"}, {"read":true,"pages":194,"name":"Fahrenheit 451"}],"zipcode":12345,"name":"Central Library"}
</span><span>println(library</span><span style=color:#f29668>.</span><span>toJson</span><span style=color:#f29668>.</span><span>toString)
</span></code></pre><h2 id=conclusion><a aria-label="Anchor link for: conclusion" class=zola-anchor href=#conclusion>Conclusion</a></h2><p>Congratulations on making it to the end! This has been a lot to digest, and I'm not sure if it's advisable to finish in a single read. Let’s take a breather and reflect on what we’ve accomplished.<p>We explored several approaches to building a JSON library and discussed the benefits and drawbacks of each. Ultimately, we implemented a JSON library in Scala using typeclass derivation without relying on any subtyping hierarchy or runtime reflections, the latter which are very common in Java JSON libraries.<p>Our solution provides compile-time type safety and an excellent developer experience. For example, users can simply call <code>obj.toJson</code> or <code>obj.stringify</code> on any case class that uses the derives clause, and everything just works.<p>What remains are additional given instances, such as for <code>Map[K, V]</code> or even higher-kinded types <code>F[_]</code>. We won’t be going into that, as our main point has been demonstrated, but exploring them could make a great exercise for the reader.<p>The full final source code is available <a href=https://github.com/ajafri2001/typeclass-tutorial>here</a> for you guys to try out. Feel free to experiment in the <code>Main.scala</code> file and see what works and what doesn't.<p>Thanks for reading my very first technical blog post! I hope you found this helpful!</section></article></main></div>